---
description: Laravel 12, Livewire 4, Alpine.js, and TailwindCSS best practices with PHPUnit testing
alwaysApply: true
---

# Laravel & Livewire Expert Guidelines

You are an expert in Laravel, PHP, Livewire, Alpine.js, and TailwindCSS.

## Key Principles

- Write concise, technical responses with accurate PHP and Livewire examples
- Focus on component-based architecture using Livewire and Laravel's latest features
- Follow Laravel and Livewire best practices and conventions
- Use object-oriented programming with a focus on SOLID principles
- Prefer iteration and modularization over duplication
- Use descriptive variable, method, and component names
- Use lowercase with dashes for directories (e.g., app/Http/Livewire)
- Favor dependency injection and service containers

## PHP/Laravel Standards

- Use PHP 8.3+ features when appropriate (typed properties, match expressions, readonly classes)
- Follow PSR-12 coding standards
- Use strict typing: `declare(strict_types=1);`
- Utilize Laravel 12's built-in features and helpers
- Implement proper error handling and logging using Laravel's exception handling
- Create custom exceptions when necessary
- Use Laravel's validation features for form and request validation
- Implement middleware for request filtering and modification
- Utilize Laravel's Eloquent ORM for database interactions
- Use Laravel's query builder for complex database queries
- Implement proper database migrations and seeders

## Livewire 4+ Guidelines

- Use Livewire for dynamic components and real-time user interactions
- Favor the use of Livewire's lifecycle hooks and properties
- Use the latest Livewire (4.x+) features for optimization and reactivity
- Implement Blade components with Livewire directives (e.g., wire:model)
- Handle state management and form handling using Livewire properties and actions
- Use wire:loading and wire:target to provide feedback and optimize user experience
- Apply Livewire's security measures for components

## Tailwind CSS Styling

- Use Tailwind CSS 4 for styling components, following a utility-first approach
- Follow a consistent design language using Tailwind CSS classes
- Implement responsive design and mobile-first approach
- Optimize for accessibility (e.g., aria-attributes) when using components
- Use Tailwind 4's new CSS-first configuration approach in `resources/css/app.css`
- Leverage custom color palette defined in project configuration

## Testing with PHPUnit

- ALWAYS create PHPUnit tests for new features, pages, models, and functionality
- Write comprehensive test coverage for all new code
- Create Feature tests for:
  - HTTP requests and responses
  - Livewire component interactions
  - Complete user flows and scenarios
  - API endpoints and controllers
- Create Unit tests for:
  - Model methods and relationships
  - Helper functions and utilities
  - Business logic and services
  - Custom validation rules
- Use Laravel's built-in testing tools and assertions
- Test database interactions using factories and seeders
- Use `RefreshDatabase` trait for database testing
- Mock external services and dependencies when appropriate
- Write descriptive test names that explain what is being tested
- Follow AAA pattern (Arrange, Act, Assert) in test methods
- Test both happy paths and edge cases/error conditions

## Laravel Best Practices

- Use Eloquent ORM instead of raw SQL queries when possible
- Implement Repository pattern for data access layer when needed
- Use Laravel's built-in authentication and authorization features
- Utilize Laravel's caching mechanisms for improved performance
- Implement job queues for long-running tasks
- Use PHPUnit for comprehensive testing (unit tests, feature tests, integration tests)
- Write tests for all new features, models, and components
- Implement API versioning for public APIs
- Use Laravel's localization features for multi-language support
- Implement proper CSRF protection and security measures
- Use Laravel Mix or Vite for asset compilation
- Implement proper database indexing for improved query performance
- Use Laravel's built-in pagination features
- Implement proper error logging and monitoring
- Implement proper database transactions for data integrity
- Use Livewire components to break down complex UIs into smaller, reusable units
- Use Laravel's event and listener system for decoupled code
- Implement Laravel's built-in scheduling features for recurring tasks
- Always run `php artisan test` before committing code

## Essential Guidelines

- Follow Laravel's MVC and component-based architecture
- Use Laravel's routing system for defining application endpoints
- Implement proper request validation using Form Requests
- Use Livewire and Blade components for interactive UIs
- Implement proper database relationships using Eloquent
- Use Laravel's built-in authentication scaffolding
- Implement proper API resource transformations
- Use Laravel's event and listener system for decoupled code
- Use Tailwind CSS for consistent and efficient styling
- Implement complex UI patterns using Livewire and Alpine.js
- Write PHPUnit tests for all new features and functionality
- Test Livewire components using Livewire's testing utilities

## Technology Stack

- Laravel 12 (latest stable version)
- PHP 8.3+
- Livewire 4+ for real-time, reactive components
- Alpine.js for lightweight JavaScript interactions
- Tailwind CSS 4 for utility-first styling
- PHPUnit for testing (feature tests, unit tests)
- Composer for dependency management
- NPM/Yarn for frontend dependencies
